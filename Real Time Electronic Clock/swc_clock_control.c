/*
 * Filename: swc_clock_control.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 */

#include "project.h"               /* Include project-specific definitions */
#include "global.h"                /* Include global definitions and variables */
#include "rte.h"                   /* Include RTE definitions */
#include "rte_types.h"             /* Include RTE type definitions */
#include "swc_clock_control.h"     /* Include Clock Control specific definitions */

/* USER CODE START SWC_CLOCK_CONTROL_INCLUDE */

/* USER CODE END SWC_CLOCK_CONTROL_INCLUDE */

#include "sp_common_signal.h"      /* Include common signal definitions */

/* Create a static clock object to manage the clock state and data */
static Clock_t Clock_obj = {Run_State, 0, 0, EV_out_NONE};

/* USER CODE START SWC_CLOCK_CONTROL_INCLUDES */
  /**
 * Will send an acknowledge protocol
 */
void EVENT__action_EvSelSet();

/**
 * Will send and set EvNONESet
 */
void EVENT__action_EvIncSet();

/**
 * Will send and set EvNONESet
 */
void EVENT__action_EvNONESet();


/** ---------------------------------- TO DO CLOCK ACTIONS -------------------------------------- **/

void RUNSTATE__action_NormalClockRun();

void HOURSTATE__action_IncHourValue();

void MINUTESTATE__action_IncMinutesValue();

/* Dummy Implementations of Helper Functions */


Clock_state getState() {
    return Clock_obj.state;
}

void setState(Clock_state state) {
    Clock_obj.state = state;
    
}
    /**
 * function pointer used for actions
 */
typedef void (*STATE_ActionPtr_t)();

/**
 * function pointer used for guards
 */
typedef int (*STATE_GuardPtr_t)();

/** State Transition Table Entry */
typedef struct
{
Clock_state fromState;
EVENT_in_t event;
Clock_state toState;
STATE_GuardPtr_t guard;
STATE_ActionPtr_t actionTransition;
} STATE_stateTransition_t;
/** State Action */
typedef struct
{
Clock_state state;
STATE_ActionPtr_t actionEntry;
STATE_ActionPtr_t actionExit;
} STATE_stateAction_t;

/* USER CODE END SWC_CLOCK_CONTROL_INCLUDES */
const STATE_stateTransition_t STATE_Alive_Transitions[] = {
    /* FromState     Event          ToState        Guard  Action */
    
    { Run_State,     EV_SEL,        Hours_State,   0,     EVENT__action_EvSelSet             },
    { Run_State,     EV_1MIN,       Run_State,     0,     RUNSTATE__action_NormalClockRun    },
    { Run_State,     EV_NONE,       Run_State,     0,     EVENT__action_EvNONESet            },
    { Hours_State,   EV_SEL,        Minutes_State, 0,     EVENT__action_EvSelSet             },
    { Hours_State,   EV_INC,        Hours_State,   0,     HOURSTATE__action_IncHourValue     },
    { Hours_State,   EV_NONE,       Hours_State,   0,     EVENT__action_EvNONESet            },
    { Minutes_State, EV_SEL,        Run_State,     0,     EVENT__action_EvSelSet             },
    { Minutes_State, EV_INC,        Minutes_State, 0,     MINUTESTATE__action_IncMinutesValue},
    { Minutes_State, EV_NONE,       Minutes_State, 0,     EVENT__action_EvNONESet            },
    { 0,             0,             0,             0,     0                                  } /* End of table record – must be unique */
};


const STATE_stateAction_t STATE_Alive_StateActions[] = {
    /* State        Entry Exit */
    { Run_State,    0,    0    },
    { Hours_State,  0,    0    },
    { Minutes_State,0,    0    },
    { 0,            0,    0    } /* End of table record – must be unique */
};

void STATE_processEvent(EVENT_in_t ev) {
    Clock_state currentState = getState();
    int i = 0, j = 0, flag=0;

    while (flag==0) 
{
        STATE_stateTransition_t transition = STATE_Alive_Transitions[i++];
        
        if ((transition.fromState == currentState) && (transition.event == ev)) {
            Clock_state toState = transition.toState;
            STATE_GuardPtr_t guard = transition.guard;
            STATE_ActionPtr_t action = transition.actionTransition;

            if (guard == NULL || guard() == 1) {
                STATE_ActionPtr_t entry = NULL;
                STATE_ActionPtr_t exit  = NULL;

                while (STATE_Alive_StateActions[j].state != 0) {
                    STATE_stateAction_t stateActions = STATE_Alive_StateActions[j++];
                    if (stateActions.state == toState) {
                        entry = stateActions.actionEntry;
                    }
                    if (stateActions.state == currentState) {
                        exit = stateActions.actionExit;
                    }
                }

                if (exit != NULL) exit();
                if (action != NULL) action();
                if (entry != NULL) entry();
                setState(toState);
                flag=1;
            }
            
        }
        
    }
} 


void EVENT__action_EvSelSet()
{

    Clock_obj.m_ev = EV_out_SEL;

}

/**
 * Will send and set EvNONESet
 */
void EVENT__action_EvIncSet()
{

    Clock_obj.m_ev = EV_out_INC;

}

/**
 * Will send and set EvNONESet
 */
void EVENT__action_EvNONESet()
{
	
    Clock_obj.m_ev = EV_out_NONE;

}
/** ---------------------------------- TO DO CLOCK ACTIONS -------------------------------------- **/

void RUNSTATE__action_NormalClockRun()
{
    
    Clock_obj.Minutes++;

    if (Clock_obj.Minutes >= 60)
    {
        Clock_obj.Hours   = (Clock_obj.Hours + 1) % 24;
        Clock_obj.Minutes = 0;
    }
    Clock_obj.m_ev = EV_out_NONE;
    
    
}

void HOURSTATE__action_IncHourValue()
{
    
    Clock_obj.Hours  = (Clock_obj.Hours + 1) % 24;
    Clock_obj.m_ev   = EV_out_INC;
    
}

void MINUTESTATE__action_IncMinutesValue()
{
    
    Clock_obj.Minutes = (Clock_obj.Minutes + 1) % 60;
    Clock_obj.m_ev    = EV_out_INC;
    
}

/* USER CODE END SWC_CLOCK_CONTROL_USERDEFINITIONS */

/*
 * component: swc_Clock_Control
 * cycletime: 1000
 * description: This Runnable operates the state machine of the clock.
 * events: ev_event_signal_onData
 * name: CLOCK_CONTROL__run
 * shortname: 
 * signalIN: so_Event_Signal
 * signalOUT: so_Clock_Signal
 * task: tsk_Clock_Control
 */
void CLOCK_CONTROL__run(RTE_event ev)
{
    /* USER CODE START CLOCK_CONTROL__run */
    /* Get the state machine event signal */
    SC_EVENT_SIGNAL_data_t State_Machine_Ev = RTE_SC_EVENT_SIGNAL_get(&SO_EVENT_SIGNAL_signal);
    SC_CLOCK_SIGNAL_data_t Clock_Signal_Data;

    /* Run the Clock Adjust state machine */

	//Execute Connection State Machine
	STATE_processEvent(State_Machine_Ev.m_ev);
    
    /* Assign the values of the State, Hours and Minutes to the Clock signal */
    Clock_Signal_Data.Clock_Data.state   = Clock_obj.state;
    Clock_Signal_Data.Clock_Data.Minutes = Clock_obj.Minutes;
    Clock_Signal_Data.Clock_Data.Hours   = Clock_obj.Hours;
    Clock_Signal_Data.Clock_Data.m_ev    = Clock_obj.m_ev;
    /* Set Clock Signal */
    RTE_SC_CLOCK_SIGNAL_set(&SO_CLOCK_SIGNAL_signal, Clock_Signal_Data);
    
    /* USER CODE END CLOCK_CONTROL__run */
}

/* USER CODE START SWC_CLOCK_CONTROL_FUNCTIONS */

/* Function to automatically run the clock, incrementing minutes and handling overflow 
 * This function increments the clock's minutes and handles the hour rollover when minutes reach 60.
 */
void Clock_Auto_Run()
{
    Clock_obj.Minutes++;

    if (Clock_obj.Minutes >= 60)
    {
        Clock_obj.Hours = (Clock_obj.Hours + 1) % 24;
        Clock_obj.Minutes = 0;
    }
}
/* USER CODE END SWC_CLOCK_CONTROL_FUNCTIONS */
